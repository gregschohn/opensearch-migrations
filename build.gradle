plugins {
    id "com.dorongold.task-tree" version "2.1.1"
    id 'io.freefair.lombok' version '8.6' apply false
    id "com.diffplug.spotless" version '6.25.0'
    id 'me.champeau.jmh' version '0.7.2' apply false // what is this?
    id 'jacoco'
    id 'net.ltgt.errorprone' version '4.0.1' apply false
}

allprojects {
    apply plugin: 'jacoco'
    repositories {
        mavenCentral()
    }
}

spotless {
    format 'misc', {
        target '**/*.gradle', '.gitattributes', '.gitignore'
        targetExclude '**/build/**'
        trimTrailingWhitespace()
        indentWithSpaces()
        endWithNewline()

    }
    yaml {
        target '**/*.yml'
        targetExclude '**/node_modules/**', '**/opensearch-cluster-cdk/**', '**/cdk.out/**'
        trimTrailingWhitespace()
        indentWithSpaces()
        endWithNewline()
    }
    json {
        target 'deployment/cdk/opensearch-service-migration/*.json'
        prettier()
        endWithNewline()
    }
}

subprojects { subproject ->
    apply plugin: "com.diffplug.spotless"

    // See https://github.com/diffplug/spotless/tree/main/plugin-gradle#java for some documentation,
    // though what '#' does is still undocumented from what I can tell
    spotless {
        java {
            target "**/*.java"
            targetExclude '**/build/**', ".gradle/**"
            importOrder(
                    'javax',
                    'java',
                    'org.opensearch',
                    '',
                    '\\#')
            indentWithSpaces()
            endWithNewline()
            removeUnusedImports()
        }
    }
}

gradle.projectsEvaluated {
    List<Task> isolatedTestsTasks = []
    List<Task> sharedProcessTestsTasks = []
    subprojects { subproject ->
        subproject.tasks.withType(Test).all { task ->
            if (task.name == "isolatedTest") {
                isolatedTestsTasks.add(task)
            } else {
                sharedProcessTestsTasks.add(task)
            }
        }
    }
    isolatedTestsTasks.sort { task -> task.project.name }

    // Create a sequential dependency chain
    Task previousTask = null
    isolatedTestsTasks.each { task ->
        sharedProcessTestsTasks.forEach {task.mustRunAfter(it) }
        if (previousTask != null) {
            task.mustRunAfter(previousTask)
        }
        previousTask = task
    }

    tasks.register("allTests") {
        dependsOn sharedProcessTestsTasks
        dependsOn isolatedTestsTasks
    }
}

task buildDockerImages() {
    dependsOn(':TrafficCapture:dockerSolution:buildDockerImages')
    dependsOn(':DocumentsFromSnapshotMigration:buildDockerImages')
}
//
//tasks.register('mergeJacocoReports', JacocoReport) {
//    afterEvaluate {
//        def jacocoReportTasks = subprojects.collect { it.tasks.withType(JacocoReport).matching { it.name == "jacocoTestReport" } }.flatten()
//        dependsOn jacocoReportTasks
//
//        additionalSourceDirs.setFrom(files(jacocoReportTasks.collect { it.additionalSourceDirs }.flatten()))
//        sourceDirectories.setFrom(files(jacocoReportTasks.collect { it.sourceDirectories }.flatten()))
//        classDirectories.setFrom(files(subprojects.collect { subproject ->
//            subproject.sourceSets.main.output.classesDirs.filter { dir ->
//                !dir.path.contains('captureProtobufs') && !dir.path.contains('trafficCaptureProxyServerTest')
//            }
//        }))
//        executionData.setFrom(files(jacocoReportTasks.collect { it.executionData }.flatten()))
//
//        reports {
//            xml.required = true
//            xml.destination = file("${buildDir}/reports/jacoco/mergedReport/jacocoMergedReport.xml")
//            html.required = true
//            html.destination = file("${buildDir}/reports/jacoco/mergedReport/html")
//        }
//    }
//}

task listPublishedArtifacts {
    doLast {
        subprojects.each { proj ->
            def publishingExtension = proj.extensions.findByType(PublishingExtension)
            if (publishingExtension) {
                publishingExtension.publications.each { publication ->
                    if (publication instanceof MavenPublication) {
                        println "${publication.groupId}.${publication.artifactId}"
                    }
                }
            }
        }
    }
}
