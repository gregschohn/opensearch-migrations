// Special Notations
// synthetic/out - these values don't get manifested in the final serialization of the object.  Only for reference.
// const - compile time constant
// readonly - cannot be set, these are values that will be derived from other values
// ? on a property - optional, property does not need to be set.
// <> notation follows a rough approximation of C++'s, ML, Java's templates/generics
// assert - a model time check.  Ideally these are static asserts (syntax errors) but they might be manifested only when we evaluate a model into its final output

// Scope Rules
// All values above the current object/scope and their immediate siblings can be referenced.
// Scoping works upward, with the first hit being returned.
// We may want to consider detecting when there was another named object farther up and throw an error.
// That collision case should be unlikely since we're setting the field names/keywords.

// All types

noBracesString: !~"[{]{2}|[}]{2}"
base64: =~"^[-A-Za-z0-9+/]*={0,3}$"

FIELD_NAME: noBracesString | (noBracesString + "?") // for optional fields

RuntimeType: int | real | string | boolean | list | struct<S> // S is only for DSL, at workflow runtime, the S typeinfo isn't preserved
struct<S>: S // { (FIELD_NAME: RuntimeType)... }
list: RuntimeType[] // n instances of the same type

Expression<T> {
  const type: T // do something to disambiguate these fields
}

ValueFromPartialPath<T> {
  const type: T
}

// see https://argo-workflows.readthedocs.io/en/latest/variables/
// in addition to values coming from workflow/input/output parameters, there are lots of other parameters present too
ValueFromTemplate<T> { // can be converted to an ArgoString<T>
  const type: T
}

TemplateValues<PREFIX, VALUES : Map<String, ValueFromPartialPath<?>> {
  [foreach k,v in VALUES { k: ValueFromTemplate<v.type> } ]
}

ValueFromConfigMap<T> {
  map: ArgoExpValue<string>
  key: ArgoExpValue<string>
  const type: T
}

ValueFromExpression {
  expression: Expression
}

Expr.LiteralValue<int>: int
Expr.LiteralValue<real>: real
Expr.LiteralValue<string>: noBracesString // notice that any argo expression's string shouldn't contain braces
Expr.LiteralValue<boolean>: boolean
Expr.LiteralValue<struct<T>>: struct<T>
Expr.LiteralValue<list<T>>: list<T>
Expr.NullableLiteralValue<T>: SOME(Expr.LiteralValue<T>) | NONE
ArgoExpValue<T>: Expr.LiteralValue<T> | ValueFromTemplate<T> | ValueFromExpression<T> | ArgoString<T>
ArgoParamValue<T>: ArgoExpValue<T> | ValueFromConfigMap<T>

// see https://expr-lang.org/docs/language-definition.
// since this language isn't typed for structs and lists, we have some utilities to marshall between our models,
// which are idealized, and the argo implementations, which will be in string form.

Expr.Concat : Expression<string> {
  list: ArgoExpValue<string>[]
}

Expr.Ternary<T> : Expression<T> {
  boolCondition: ArgoExpValue<Bool>
  whenTrue: ArgoExpValue<T>
  whenFalse: ArgoExpValue<T>
}

Expr.NilCoalesce<T> : Expression<T> {
  primaryValue: ArgoExpValue<T>
  backupValue: ArgoExpValue<T>
}

Expr.FormatString : Expression<string> {
  format: string // use something like {} or {INT} as placeholders
  args: ArgoExpValue<T>[]
}

Expr.MakeStruct<T> : Expression<struct<T>> {
  bindings: Map<String, ArgoExpValue<struct<T>>>
}

// At runtime, this will cause an error if the value isn't found,
// though the schema shouldn't let us get to doing the lookup in Argo logic.
// At compile time, this should throw an error if the field is optional
Expr.Get<T> : Expression<T> {
  fieldName: string
  data: struct<>
  const type: T
  assert(typeof(data[fieldName] == T))
}

// At runtime, a lookup on fieldName could return null (rendered as "")
Expr.GetNullable<T> : Expression<T> {
  fieldName: string
  data: struct<>
  const type: Nullable<T>
  assert(typeof(data[fieldName] == Nullable<T>))
}

FromSchema<OUTER, SCHEMA, PATHS_FOR_TEMPLATE_SUBS, OTHER_FIELDS_TO_TOTALLY_RESTRICT, ALL_FIELDS_FOR_TEMPLATING> {
  OUT = struct<NEWLY_DERIVED_STRUCT>
  // magic to import a schema for SOURCE into a new class that has getters for everything in the schema.
  // The OUT class will have only setters accessible through the constructor and ONLY the fields that were
  // not within OTHER_FIELDS_TO_TOTALLY_RESTRICT may be passed in via that constructor.  Those fields within
  // OTHER_FIELDS_TO_TOTALLY_RESTRICT will be set directly by the constructor by deriving/copying values that
  // were passed into it.

  // When ALL_FIELDS_FOR_TEMPLATING is false, field paths that match PATHS_FOR_TEMPLATE_SUBS can be ArgoExpValue<string>
  // and otherwise all types are unchanged.
  // When ALL_FIELDS_FOR_TEMPLATING is true, all field paths can be of type ArgoExpValue<T> where T is the original value
  // of the source field.

  // The above means that if a user tries to set a value for something that the generator class already intends
  // to handle (e.g. templateRef), that will be a syntax error.
  // If a user tries to set an ArgoExpValue (e.g. something that resolves to "{{inputs...}}") for a value that's
  // still only of type string, int, etc, that will be a syntax error.
}

FromSchema<OUTER, SCHEMA, PATHS_FOR_TEMPLATE_SUBS, OTHER_FIELDS_TO_TOTALLY_RESTRICT> :
  FromSchema<OUTER, SCHEMA, PATHS_FOR_TEMPLATE_SUBS, OTHER_FIELDS_TO_TOTALLY_RESTRICT, false> {}

Container<FOR_MANIFEST> :
 FromSchema<Container<FOR_WHAT>, "io.k8s.api.core.v1.Container", FOR_MANIFEST, [...TO_DO...], ["env"]>.OUT
{
  inputs: Map<string(op), IncomingParameter<T>>
  synthetic inputs: Map<string, NamedParameter<T>>
  name?: string | "main" // default
  image: string | inputs["image"]
  imagePullPolicy: string | inputs["imagePullPolicy"]
  extraEnvVars: Map<String, String>
  const type: T
}

JibContainer<FOR_MANIFEST> : Container<FOR_MANIFEST> {}
BashContainer<FOR_MANIFEST> : Container<FOR_MANIFEST> {
  command: string
}

ParameterDefinition<T> :
  FromSchema<Container<FOR_WHAT>, "io.argoproj.workflow.v1alpha1.Parameter", FOR_MANIFEST, [...TO_DO...], ["value"]>.OUT {
  const type: T
}

OutputParameter<T> : ParameterDefinition<T> {
  value: ArgoExpValue<T>
}

IncomingParameter<T> : ParameterDefinition<T> {
  defaultValue?: ArgoParamValue<T>
  description?: string
}

InputParameterDefinition<T>: IncomingParameter<T> {
  // only applicable when this is defined within a script, container, or K8s with a container
  passToContainer?: boolean = true // default
  requiredArg?: boolean = false // default
  assert(requiredArg == false || defaultValue == null)
}

WorkflowParameterDefinition<T> : IncomingParameter<T> {
}

NamedParameter<T, PARAM_TYPE=ParameterDefinition<T>> {{ // constrain PARAM_TYPE to NamedParameter<T> or subclass
  name: string
  definition: PARAM_TYPE
}

// instance of a template - there can be many versions of a single template.
// Think of this as a call-site
WorkflowTask<T> {
  templateRef: WorkflowTemplate<T>
  argumentMappings?: Map<String, ArgoParamValue<>>
  when?: ArgoExprValue<boolean>
  {
    loop: ArgoExpValue<list<T>>
    synthetic loop: { item: T }
  }

  assert(... foreach key in argument mappings, the argumentMappings[k].type == templateRef.inputs[k].type ...)
  assert(... all required args in templateRef have keys in argumentMappings ...)
  RESULTS {
    name: ValueFromPartialPath<string>
    [foreach p in [id, ip, status, hostNodeName, result /* would resultText be more useful & special case the conversion */]
      {p: ValueFromPartialPath<string>}]
    [foreach p in [exitCode, startedAt, finishedAt ] {p: ValueFromPartialPath<string>}]
    outputs.parameters: [foreach o in templateRef.outputs {o.name: ValueFromPartialPath<o.type>}]
  }
}

StepTask<T> : WorkflowTask<T> {
}

DagTask<T> : WorkflowTask<T> {
  dependsOn?: string[] // don't bother modeling the other depends field for the other direction
}

// this is the function to be called by others
WorkflowTemplate {
  name: string
  // if an input is specified with a '?' at the end, then it is constructed with requiredArg=false
  // else requiredArg = !(the definition's defaultValue)
  inputs?: Map<string, InputParameterDefinition>
  outputs?: Map<string, OutputParameterDefinition>

  readonly properties { // https://argo-workflows.readthedocs.io/en/latest/variables/#all-templates
    nodeName: ValueFromTemplate<string>
    inputs.parameters: [foreach i in inputs {i.name: ValueFromTemplate<i.type>}]
    // inputs.artifacts // would need to add support.  I don't think that this comes naturally from the schema
  }
}

Workflow.Dag : WorkflowTemplate {
  tasks: Map<String,DagTask>
  readonly templates:
  synthetic tasks { // https://argo-workflows.readthedocs.io/en/latest/variables/#dag-templates
    [foreach t in tasks {t.name: TemplateValues<"tasks."+t.name, t.type>}]
  }
}

Workflow.Steps : WorkflowTemplate {
  tasks: StepTask[][]
  readonly results { // https://argo-workflows.readthedocs.io/en/latest/variables/#steps-templates
    steps: [foreach t in tasks {t.name: ValueFromTemplate<i.type>}]
  }
}

Workflow.Suspend : WorkflowTemplate {}
Workflow.DoNothing : WorkflowTemplate {}
Workflow.Container : WorkflowTemplate {
  container: Container
}

Workflow.Resource<SCHEMA> : WorkflowTemplate {
  manifest: ArgoExpValue<struct<SCHEMA>>
}

K8sTemplate {
  serviceAccountName: string
  name: string
  workflowParameters: Map<String, WorkflowParameterDefinition<> >
  templates: Map<String, WorkflowTemplate>
}

// helpers

ArgsFor<T : WorkflowTemplate> { OUT=Map<String, ArgoExpValue<?>> }
invoke<T : WorkflowTemplate>(T template, ...ArgsFor<T>.OUT) -> WorkflowTask
unrollStructToArgs(struct<T>, WorkflowTemplate) -> Map<String, ArgoParamValue<>>